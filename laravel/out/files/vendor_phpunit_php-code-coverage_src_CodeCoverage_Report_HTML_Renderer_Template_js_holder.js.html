<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>vendor/phpunit/php-code-coverage/src/CodeCoverage/Report/HTML/Renderer/Template/js/holder.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title=""></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Courses.html">Courses</a></li>
                                <li><a href="../classes/Forms.html">Forms</a></li>
                                <li><a href="../classes/Main.html">Main</a></li>
                                <li><a href="../classes/Validations.html">Validations</a></li>
                                <li><a href="../classes/.html"></a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: vendor/phpunit/php-code-coverage/src/CodeCoverage/Report/HTML/Renderer/Template/js/holder.js</h1>
                        
                        <div class="file">
                            <pre class="code prettyprint linenums">
                        /*
                        Holder.js - client side image placeholders
                        © 2012-2014 Ivan Malopinsky - http://imsky.co
                        */
                        (function(register, global, undefined) {
                        
                        	//Constants and definitions
                        
                        	var SVG_NS = &#x27;http://www.w3.org/2000/svg&#x27;;
                        	var document = global.document;
                        
                        	var Holder = {
                        		/**
                        		 * Adds a theme to default settings
                        		 *
                        		 * @param {string} name Theme name
                        		 * @param {Object} theme Theme object, with foreground, background, size, font, and fontweight properties.
                        		 */
                        		addTheme: function(name, theme) {
                        			name != null &amp;&amp; theme != null &amp;&amp; (App.settings.themes[name] = theme);
                        			delete App.vars.cache.themeKeys;
                        			return this;
                        		},
                        
                        		/**
                        		 * Appends a placeholder to an element
                        		 *
                        		 * @param {string} src Placeholder URL string
                        		 * @param {string} el Selector of target element(s)
                        		 */
                        		addImage: function(src, el) {
                        			var node = document.querySelectorAll(el);
                        			if (node.length) {
                        				for (var i = 0, l = node.length; i &lt; l; i++) {
                        					var img = newEl(&#x27;img&#x27;);
                        					setAttr(img, {
                        						&#x27;data-src&#x27;: src
                        					});
                        					node[i].appendChild(img);
                        				}
                        			}
                        			return this;
                        		},
                        
                        		/**
                        		 * Runs Holder with options. By default runs Holder on all images with &quot;holder.js&quot; in their source attributes.
                        		 *
                        		 * @param {Object} userOptions Options object, can contain domain, themes, images, and bgnodes properties
                        		 */
                        		run: function(userOptions) {
                        			userOptions = userOptions || {};
                        			var renderSettings = {};
                        
                        			App.vars.preempted = true;
                        
                        			var options = extend(App.settings, userOptions);
                        
                        			renderSettings.renderer = options.renderer ? options.renderer : App.setup.renderer;
                        			if (App.setup.renderers.join(&#x27;,&#x27;).indexOf(renderSettings.renderer) === -1) {
                        				renderSettings.renderer = App.setup.supportsSVG ? &#x27;svg&#x27; : (App.setup.supportsCanvas ? &#x27;canvas&#x27; : &#x27;html&#x27;);
                        			}
                        
                        			//&lt; v2.4 API compatibility
                        			if (options.use_canvas) {
                        				renderSettings.renderer = &#x27;canvas&#x27;;
                        			} else if (options.use_svg) {
                        				renderSettings.renderer = &#x27;svg&#x27;;
                        			}
                        
                        			var images = getNodeArray(options.images);
                        			var bgnodes = getNodeArray(options.bgnodes);
                        			var stylenodes = getNodeArray(options.stylenodes);
                        			var objects = getNodeArray(options.objects);
                        
                        			renderSettings.stylesheets = [];
                        			renderSettings.svgXMLStylesheet = true;
                        			renderSettings.noFontFallback = options.noFontFallback ? options.noFontFallback : false;
                        
                        			for (var i = 0; i &lt; stylenodes.length; i++) {
                        				var styleNode = stylenodes[i];
                        				if (styleNode.attributes.rel &amp;&amp; styleNode.attributes.href &amp;&amp; styleNode.attributes.rel.value == &#x27;stylesheet&#x27;) {
                        					var href = styleNode.attributes.href.value;
                        					//todo: write isomorphic relative-to-absolute URL function
                        					var proxyLink = newEl(&#x27;a&#x27;);
                        					proxyLink.href = href;
                        					var stylesheetURL = proxyLink.protocol + &#x27;//&#x27; + proxyLink.host + proxyLink.pathname + proxyLink.search;
                        					renderSettings.stylesheets.push(stylesheetURL);
                        				}
                        			}
                        
                        			for (i = 0; i &lt; bgnodes.length; i++) {
                        				var backgroundImage = global.getComputedStyle(bgnodes[i], null).getPropertyValue(&#x27;background-image&#x27;);
                        				var dataBackgroundImage = bgnodes[i].getAttribute(&#x27;data-background-src&#x27;);
                        				var rawURL = null;
                        
                        				if (dataBackgroundImage == null) {
                        					rawURL = backgroundImage;
                        				} else {
                        					rawURL = dataBackgroundImage;
                        				}
                        
                        				var holderURL = null;
                        				var holderString = &#x27;?&#x27; + options.domain + &#x27;/&#x27;;
                        
                        				if (rawURL.indexOf(holderString) === 0) {
                        					holderURL = rawURL.slice(1);
                        				} else if (rawURL.indexOf(holderString) != -1) {
                        					var fragment = rawURL.substr(rawURL.indexOf(holderString)).slice(1);
                        					var fragmentMatch = fragment.match(/([^\&quot;]*)&quot;?\)/);
                        
                        					if (fragmentMatch != null) {
                        						holderURL = fragmentMatch[1];
                        					}
                        				}
                        
                        				if (holderURL != null) {
                        					var holderFlags = parseURL(holderURL, options);
                        					if (holderFlags) {
                        						prepareDOMElement(&#x27;background&#x27;, bgnodes[i], holderFlags, renderSettings);
                        					}
                        				}
                        			}
                        
                        			for (i = 0; i &lt; objects.length; i++) {
                        				var object = objects[i];
                        				var objectAttr = {};
                        
                        				try {
                        					objectAttr.data = object.getAttribute(&#x27;data&#x27;);
                        					objectAttr.dataSrc = object.getAttribute(&#x27;data-src&#x27;);
                        				} catch (e) {}
                        
                        				var objectHasSrcURL = objectAttr.data != null &amp;&amp; objectAttr.data.indexOf(options.domain) === 0;
                        				var objectHasDataSrcURL = objectAttr.dataSrc != null &amp;&amp; objectAttr.dataSrc.indexOf(options.domain) === 0;
                        
                        				if (objectHasSrcURL) {
                        					prepareImageElement(options, renderSettings, objectAttr.data, object);
                        				} else if (objectHasDataSrcURL) {
                        					prepareImageElement(options, renderSettings, objectAttr.dataSrc, object);
                        				}
                        			}
                        
                        			for (i = 0; i &lt; images.length; i++) {
                        				var image = images[i];
                        				var imageAttr = {};
                        
                        				try {
                        					imageAttr.src = image.getAttribute(&#x27;src&#x27;);
                        					imageAttr.dataSrc = image.getAttribute(&#x27;data-src&#x27;);
                        					imageAttr.rendered = image.getAttribute(&#x27;data-holder-rendered&#x27;);
                        				} catch (e) {}
                        
                        				var imageHasSrc = imageAttr.src != null;
                        				var imageHasDataSrcURL = imageAttr.dataSrc != null &amp;&amp; imageAttr.dataSrc.indexOf(options.domain) === 0;
                        				var imageRendered = imageAttr.rendered != null &amp;&amp; imageAttr.rendered == &#x27;true&#x27;;
                        
                        				if (imageHasSrc) {
                        					if (imageAttr.src.indexOf(options.domain) === 0) {
                        						prepareImageElement(options, renderSettings, imageAttr.src, image);
                        					} else if (imageHasDataSrcURL) {
                        						//Image has a valid data-src and an invalid src
                        						if (imageRendered) {
                        							//If the placeholder has already been render, re-render it
                        							prepareImageElement(options, renderSettings, imageAttr.dataSrc, image);
                        						} else {
                        							//If the placeholder has not been rendered, check if the image exists and render a fallback if it doesn&#x27;t
                                      (function(src, options, renderSettings, dataSrc, image){
                                        imageExists(src, function(exists){
                                          if(!exists){
                                            prepareImageElement(options, renderSettings, dataSrc, image);
                                          }
                                        });
                                      })(imageAttr.src, options, renderSettings, imageAttr.dataSrc, image);
                        						}
                        					}
                        				} else if (imageHasDataSrcURL) {
                        					prepareImageElement(options, renderSettings, imageAttr.dataSrc, image);
                        				}
                        			}
                        
                        			return this;
                        		},
                        		//todo: remove invisibleErrorFn for 2.5
                        		invisibleErrorFn: function(fn) {
                        			return function(el) {
                        				if (el.hasAttribute(&#x27;data-holder-invisible&#x27;)) {
                        					throw &#x27;Holder: invisible placeholder&#x27;;
                        				}
                        			};
                        		}
                        	};
                        
                        	//&lt; v2.4 API compatibility
                        
                        	Holder.add_theme = Holder.addTheme;
                        	Holder.add_image = Holder.addImage;
                        	Holder.invisible_error_fn = Holder.invisibleErrorFn;
                        
                        	var App = {
                        		settings: {
                        			domain: &#x27;holder.js&#x27;,
                        			images: &#x27;img&#x27;,
                        			objects: &#x27;object&#x27;,
                        			bgnodes: &#x27;body .holderjs&#x27;,
                        			stylenodes: &#x27;head link.holderjs&#x27;,
                        			stylesheets: [],
                        			themes: {
                        				&#x27;gray&#x27;: {
                        					background: &#x27;#EEEEEE&#x27;,
                        					foreground: &#x27;#AAAAAA&#x27;
                        				},
                        				&#x27;social&#x27;: {
                        					background: &#x27;#3a5a97&#x27;,
                        					foreground: &#x27;#FFFFFF&#x27;
                        				},
                        				&#x27;industrial&#x27;: {
                        					background: &#x27;#434A52&#x27;,
                        					foreground: &#x27;#C2F200&#x27;
                        				},
                        				&#x27;sky&#x27;: {
                        					background: &#x27;#0D8FDB&#x27;,
                        					foreground: &#x27;#FFFFFF&#x27;
                        				},
                        				&#x27;vine&#x27;: {
                        					background: &#x27;#39DBAC&#x27;,
                        					foreground: &#x27;#1E292C&#x27;
                        				},
                        				&#x27;lava&#x27;: {
                        					background: &#x27;#F8591A&#x27;,
                        					foreground: &#x27;#1C2846&#x27;
                        				}
                        			}
                        		},
                            defaults: {
                              size: 10,
                              units: &#x27;pt&#x27;,
                              scale: 1/16
                            },
                        		flags: {
                        			dimensions: {
                        				regex: /^(\d+)x(\d+)$/,
                        				output: function(val) {
                        					var exec = this.regex.exec(val);
                        					return {
                        						width: +exec[1],
                        						height: +exec[2]
                        					};
                        				}
                        			},
                        			fluid: {
                        				regex: /^([0-9]+%?)x([0-9]+%?)$/,
                        				output: function(val) {
                        					var exec = this.regex.exec(val);
                        					return {
                        						width: exec[1],
                        						height: exec[2]
                        					};
                        				}
                        			},
                        			colors: {
                        				regex: /(?:#|\^)([0-9a-f]{3,})\:(?:#|\^)([0-9a-f]{3,})/i,
                        				output: function(val) {
                        					var exec = this.regex.exec(val);
                        					return {
                        						foreground: &#x27;#&#x27; + exec[2],
                        						background: &#x27;#&#x27; + exec[1]
                        					};
                        				}
                        			},
                        			text: {
                        				regex: /text\:(.*)/,
                        				output: function(val) {
                        					return this.regex.exec(val)[1].replace(&#x27;\\/&#x27;, &#x27;/&#x27;);
                        				}
                        			},
                        			font: {
                        				regex: /font\:(.*)/,
                        				output: function(val) {
                        					return this.regex.exec(val)[1];
                        				}
                        			},
                        			auto: {
                        				regex: /^auto$/
                        			},
                        			textmode: {
                        				regex: /textmode\:(.*)/,
                        				output: function(val) {
                        					return this.regex.exec(val)[1];
                        				}
                        			},
                        			random: {
                        				regex: /^random$/
                        			}
                        		}
                        	};
                        
                        	/**
                        	 * Processes provided source attribute and sets up the appropriate rendering workflow
                        	 *
                        	 * @private
                        	 * @param options Instance options from Holder.run
                        	 * @param renderSettings Instance configuration
                        	 * @param src Image URL
                        	 * @param el Image DOM element
                        	 */
                        	function prepareImageElement(options, renderSettings, src, el) {
                        		var holderFlags = parseURL(src.substr(src.lastIndexOf(options.domain)), options);
                        		if (holderFlags) {
                        			prepareDOMElement(null, el, holderFlags, renderSettings);
                        		}
                        	}
                        
                        	/**
                        	 * Processes a Holder URL and extracts flags
                        	 *
                        	 * @private
                        	 * @param url URL
                        	 * @param options Instance options from Holder.run
                        	 */
                        	function parseURL(url, options) {
                        		var ret = {
                        			theme: extend(App.settings.themes.gray, null),
                        			stylesheets: options.stylesheets,
                        			holderURL: []
                        		};
                        		var render = false;
                        		var vtab = String.fromCharCode(11);
                        		var flags = url.replace(/([^\\])\//g, &#x27;$1&#x27; + vtab).split(vtab);
                        		var uriRegex = /%[0-9a-f]{2}/gi;
                        		for (var fl = flags.length, j = 0; j &lt; fl; j++) {
                        			var flag = flags[j];
                        			if (flag.match(uriRegex)) {
                        				try {
                        					flag = decodeURIComponent(flag);
                        				} catch (e) {
                        					flag = flags[j];
                        				}
                        			}
                        
                        			var push = false;
                        
                        			if (App.flags.dimensions.match(flag)) {
                        				render = true;
                        				ret.dimensions = App.flags.dimensions.output(flag);
                        				push = true;
                        			} else if (App.flags.fluid.match(flag)) {
                        				render = true;
                        				ret.dimensions = App.flags.fluid.output(flag);
                        				ret.fluid = true;
                        				push = true;
                        			} else if (App.flags.textmode.match(flag)) {
                        				ret.textmode = App.flags.textmode.output(flag);
                        				push = true;
                        			} else if (App.flags.colors.match(flag)) {
                        				var colors = App.flags.colors.output(flag);
                        				ret.theme = extend(ret.theme, colors);
                        				//todo: convert implicit theme use to a theme: flag
                        				push = true;
                        			} else if (options.themes[flag]) {
                        				//If a theme is specified, it will override custom colors
                        				if (options.themes.hasOwnProperty(flag)) {
                        					ret.theme = extend(options.themes[flag], null);
                        				}
                        				push = true;
                        			} else if (App.flags.font.match(flag)) {
                        				ret.font = App.flags.font.output(flag);
                        				push = true;
                        			} else if (App.flags.auto.match(flag)) {
                        				ret.auto = true;
                        				push = true;
                        			} else if (App.flags.text.match(flag)) {
                        				ret.text = App.flags.text.output(flag);
                        				push = true;
                        			} else if (App.flags.random.match(flag)) {
                        				if (App.vars.cache.themeKeys == null) {
                        					App.vars.cache.themeKeys = Object.keys(options.themes);
                        				}
                        				var theme = App.vars.cache.themeKeys[0 | Math.random() * App.vars.cache.themeKeys.length];
                        				ret.theme = extend(options.themes[theme], null);
                        				push = true;
                        			}
                        
                        			if (push) {
                        				ret.holderURL.push(flag);
                        			}
                        		}
                        		ret.holderURL.unshift(options.domain);
                        		ret.holderURL = ret.holderURL.join(&#x27;/&#x27;);
                        		return render ? ret : false;
                        	}
                        
                        	/**
                        	 * Modifies the DOM to fit placeholders and sets up resizable image callbacks (for fluid and automatically sized placeholders)
                        	 *
                        	 * @private
                        	 * @param el Image DOM element
                        	 * @param flags Placeholder-specific configuration
                        	 * @param _renderSettings Instance configuration
                        	 */
                        	function prepareDOMElement(mode, el, flags, _renderSettings) {
                        		var dimensions = flags.dimensions,
                        			theme = flags.theme;
                        		var dimensionsCaption = dimensions.width + &#x27;x&#x27; + dimensions.height;
                        		mode = mode == null ? (flags.fluid ? &#x27;fluid&#x27; : &#x27;image&#x27;) : mode;
                        
                        		if (flags.text != null) {
                        			theme.text = flags.text;
                        
                        			//&lt;object&gt; SVG embedding doesn&#x27;t parse Unicode properly
                        			if (el.nodeName.toLowerCase() === &#x27;object&#x27;) {
                        				var textLines = theme.text.split(&#x27;\\n&#x27;);
                        				for (var k = 0; k &lt; textLines.length; k++) {
                        					textLines[k] = encodeHtmlEntity(textLines[k]);
                        				}
                        				theme.text = textLines.join(&#x27;\\n&#x27;);
                        			}
                        		}
                        
                        		var holderURL = flags.holderURL;
                        		var renderSettings = extend(_renderSettings, null);
                        
                        		if (flags.font) {
                        			theme.font = flags.font;
                        			//Only run the &lt;canvas&gt; webfont fallback if noFontFallback is false, if the node is not an image, and if canvas is supported
                        			if (!renderSettings.noFontFallback &amp;&amp; el.nodeName.toLowerCase() === &#x27;img&#x27; &amp;&amp; App.setup.supportsCanvas &amp;&amp; renderSettings.renderer === &#x27;svg&#x27;) {
                        				renderSettings = extend(renderSettings, {
                        					renderer: &#x27;canvas&#x27;
                        				});
                        			}
                        		}
                        
                        		//Chrome and Opera require a quick 10ms re-render if web fonts are used with canvas
                        		if (flags.font &amp;&amp; renderSettings.renderer == &#x27;canvas&#x27;) {
                        			renderSettings.reRender = true;
                        		}
                        
                        		if (mode == &#x27;background&#x27;) {
                        			if (el.getAttribute(&#x27;data-background-src&#x27;) == null) {
                        				setAttr(el, {
                        					&#x27;data-background-src&#x27;: holderURL
                        				});
                        			}
                        		} else {
                        			setAttr(el, {
                        				&#x27;data-src&#x27;: holderURL
                        			});
                        		}
                        
                        		flags.theme = theme;
                        
                        		el.holderData = {
                        			flags: flags,
                        			renderSettings: renderSettings
                        		};
                        
                        		if (mode == &#x27;image&#x27; || mode == &#x27;fluid&#x27;) {
                        			setAttr(el, {
                        				&#x27;alt&#x27;: (theme.text ? (theme.text.length &gt; 16 ? theme.text.substring(0, 16) + &#x27;…&#x27; : theme.text) + &#x27; [&#x27; + dimensionsCaption + &#x27;]&#x27; : dimensionsCaption)
                        			});
                        		}
                        
                        		if (mode == &#x27;image&#x27;) {
                        			if (renderSettings.renderer == &#x27;html&#x27; || !flags.auto) {
                        				el.style.width = dimensions.width + &#x27;px&#x27;;
                        				el.style.height = dimensions.height + &#x27;px&#x27;;
                        			}
                        			if (renderSettings.renderer == &#x27;html&#x27;) {
                        				el.style.backgroundColor = theme.background;
                        			} else {
                        				render(mode, {
                        					dimensions: dimensions,
                        					theme: theme,
                        					flags: flags
                        				}, el, renderSettings);
                        
                        				if (flags.textmode &amp;&amp; flags.textmode == &#x27;exact&#x27;) {
                        					App.vars.resizableImages.push(el);
                        					updateResizableElements(el);
                        				}
                        			}
                        		} else if (mode == &#x27;background&#x27; &amp;&amp; renderSettings.renderer != &#x27;html&#x27;) {
                        			render(mode, {
                        					dimensions: dimensions,
                        					theme: theme,
                        					flags: flags
                        				},
                        				el, renderSettings);
                        		} else if (mode == &#x27;fluid&#x27;) {
                        			if (dimensions.height.slice(-1) == &#x27;%&#x27;) {
                        				el.style.height = dimensions.height;
                        			} else if (flags.auto == null || !flags.auto) {
                        				el.style.height = dimensions.height + &#x27;px&#x27;;
                        			}
                        			if (dimensions.width.slice(-1) == &#x27;%&#x27;) {
                        				el.style.width = dimensions.width;
                        			} else if (flags.auto == null || !flags.auto) {
                        				el.style.width = dimensions.width + &#x27;px&#x27;;
                        			}
                        			if (el.style.display == &#x27;inline&#x27; || el.style.display === &#x27;&#x27; || el.style.display == &#x27;none&#x27;) {
                        				el.style.display = &#x27;block&#x27;;
                        			}
                        
                        			setInitialDimensions(el);
                        
                        			if (renderSettings.renderer == &#x27;html&#x27;) {
                        				el.style.backgroundColor = theme.background;
                        			} else {
                        				App.vars.resizableImages.push(el);
                        				updateResizableElements(el);
                        			}
                        		}
                        	}
                        
                        	/**
                        	 * Core function that takes output from renderers and sets it as the source or background-image of the target element
                        	 *
                        	 * @private
                        	 * @param mode Placeholder mode, either background or image
                        	 * @param params Placeholder-specific parameters
                        	 * @param el Image DOM element
                        	 * @param renderSettings Instance configuration
                        	 */
                        
                        	function render(mode, params, el, renderSettings) {
                        		var image = null;
                        
                        		switch (renderSettings.renderer) {
                        			case &#x27;svg&#x27;:
                        				if (!App.setup.supportsSVG) return;
                        				break;
                        			case &#x27;canvas&#x27;:
                        				if (!App.setup.supportsCanvas) return;
                        				break;
                        			default:
                        				return;
                        		}
                        
                        		//todo: move generation of scene up to flag generation to reduce extra object creation
                        		var scene = {
                        			width: params.dimensions.width,
                        			height: params.dimensions.height,
                        			theme: params.theme,
                        			flags: params.flags
                        		};
                        
                        		var sceneGraph = buildSceneGraph(scene);
                        
                        		var rendererParams = {
                        			text: scene.text,
                        			width: scene.width,
                        			height: scene.height,
                        			textHeight: scene.font.size,
                        			font: scene.font.family,
                        			fontWeight: scene.font.weight,
                        			template: scene.theme
                        		};
                        
                        		function getRenderedImage() {
                        			var image = null;
                        			switch (renderSettings.renderer) {
                        				case &#x27;canvas&#x27;:
                        					image = sgCanvasRenderer(sceneGraph);
                        					break;
                        				case &#x27;svg&#x27;:
                        					image = sgSVGRenderer(sceneGraph, renderSettings);
                        					break;
                        				default:
                        					throw &#x27;Holder: invalid renderer: &#x27; + renderSettings.renderer;
                        			}
                        			return image;
                        		}
                        
                        		image = getRenderedImage();
                        
                        		if (image == null) {
                        			throw &#x27;Holder: couldn\&#x27;t render placeholder&#x27;;
                        		}
                        
                        		//todo: add &lt;object&gt; canvas rendering
                        		if (mode == &#x27;background&#x27;) {
                        			el.style.backgroundImage = &#x27;url(&#x27; + image + &#x27;)&#x27;;
                        			el.style.backgroundSize = scene.width + &#x27;px &#x27; + scene.height + &#x27;px&#x27;;
                        		} else {
                        			if (el.nodeName.toLowerCase() === &#x27;img&#x27;) {
                        				setAttr(el, {
                        					&#x27;src&#x27;: image
                        				});
                        			} else if (el.nodeName.toLowerCase() === &#x27;object&#x27;) {
                        				setAttr(el, {
                        					&#x27;data&#x27;: image
                        				});
                        				setAttr(el, {
                        					&#x27;type&#x27;: &#x27;image/svg+xml&#x27;
                        				});
                        			}
                        			if (renderSettings.reRender) {
                        				setTimeout(function() {
                        					var image = getRenderedImage();
                        					if (image == null) {
                        						throw &#x27;Holder: couldn\&#x27;t render placeholder&#x27;;
                        					}
                        					if (el.nodeName.toLowerCase() === &#x27;img&#x27;) {
                        						setAttr(el, {
                        							&#x27;src&#x27;: image
                        						});
                        					} else if (el.nodeName.toLowerCase() === &#x27;object&#x27;) {
                        						setAttr(el, {
                        							&#x27;data&#x27;: image
                        						});
                        						setAttr(el, {
                        							&#x27;type&#x27;: &#x27;image/svg+xml&#x27;
                        						});
                        					}
                        				}, 100);
                        			}
                        		}
                        		setAttr(el, {
                        			&#x27;data-holder-rendered&#x27;: true
                        		});
                        	}
                        
                        	/**
                        	 * Core function that takes a Holder scene description and builds a scene graph
                        	 *
                        	 * @private
                        	 * @param scene Holder scene object
                        	 */
                        	function buildSceneGraph(scene) {
                        		scene.font = {
                        			family: scene.theme.font ? scene.theme.font : &#x27;Arial, Helvetica, Open Sans, sans-serif&#x27;,
                        			size: textSize(scene.width, scene.height, scene.theme.size ? scene.theme.size : App.defaults.size),
                              units: scene.theme.units ? scene.theme.units : App.defaults.units,
                        			weight: scene.theme.fontweight ? scene.theme.fontweight : &#x27;bold&#x27;
                        		};
                        		scene.text = scene.theme.text ? scene.theme.text : Math.floor(scene.width) + &#x27;x&#x27; + Math.floor(scene.height);
                        
                        		switch (scene.flags.textmode) {
                        			case &#x27;literal&#x27;:
                        				scene.text = scene.flags.dimensions.width + &#x27;x&#x27; + scene.flags.dimensions.height;
                        				break;
                        			case &#x27;exact&#x27;:
                        				if (!scene.flags.exactDimensions) break;
                        				scene.text = Math.floor(scene.flags.exactDimensions.width) + &#x27;x&#x27; + Math.floor(scene.flags.exactDimensions.height);
                        				break;
                        		}
                        
                        		var sceneGraph = new SceneGraph({
                        			width: scene.width,
                        			height: scene.height
                        		});
                        
                        		var Shape = sceneGraph.Shape;
                        
                        		var holderBg = new Shape.Rect(&#x27;holderBg&#x27;, {
                        			fill: scene.theme.background
                        		});
                        
                        		holderBg.resize(scene.width, scene.height);
                        		sceneGraph.root.add(holderBg);
                        
                        		var holderTextGroup = new Shape.Group(&#x27;holderTextGroup&#x27;, {
                        			text: scene.text,
                        			align: &#x27;center&#x27;,
                        			font: scene.font,
                        			fill: scene.theme.foreground
                        		});
                        
                        		holderTextGroup.moveTo(null, null, 1);
                        		sceneGraph.root.add(holderTextGroup);
                        
                        		var tpdata = holderTextGroup.textPositionData = stagingRenderer(sceneGraph);
                        		if (!tpdata) {
                        			throw &#x27;Holder: staging fallback not supported yet.&#x27;;
                        		}
                        		holderTextGroup.properties.leading = tpdata.boundingBox.height;
                        
                        		//todo: alignment: TL, TC, TR, CL, CR, BL, BC, BR
                        		var textNode = null;
                        		var line = null;
                        
                        		function finalizeLine(parent, line, width, height) {
                        			line.width = width;
                        			line.height = height;
                        			parent.width = Math.max(parent.width, line.width);
                        			parent.height += line.height;
                        			parent.add(line);
                        		}
                        
                        		if (tpdata.lineCount &gt; 1) {
                        			var offsetX = 0;
                        			var offsetY = 0;
                        			var maxLineWidth = scene.width * App.setup.lineWrapRatio;
                        			var lineIndex = 0;
                        			line = new Shape.Group(&#x27;line&#x27; + lineIndex);
                        
                        			for (var i = 0; i &lt; tpdata.words.length; i++) {
                        				var word = tpdata.words[i];
                        				textNode = new Shape.Text(word.text);
                        				var newline = word.text == &#x27;\\n&#x27;;
                        				if (offsetX + word.width &gt;= maxLineWidth || newline === true) {
                        					finalizeLine(holderTextGroup, line, offsetX, holderTextGroup.properties.leading);
                        					offsetX = 0;
                        					offsetY += holderTextGroup.properties.leading;
                        					lineIndex += 1;
                        					line = new Shape.Group(&#x27;line&#x27; + lineIndex);
                        					line.y = offsetY;
                        				}
                        				if (newline === true) {
                        					continue;
                        				}
                        				textNode.moveTo(offsetX, 0);
                        				offsetX += tpdata.spaceWidth + word.width;
                        				line.add(textNode);
                        			}
                        
                        			finalizeLine(holderTextGroup, line, offsetX, holderTextGroup.properties.leading);
                        
                        			for (var lineKey in holderTextGroup.children) {
                        				line = holderTextGroup.children[lineKey];
                        				line.moveTo(
                        					(holderTextGroup.width - line.width) / 2,
                        					null,
                        					null);
                        			}
                        
                        			holderTextGroup.moveTo(
                        				(scene.width - holderTextGroup.width) / 2, (scene.height - holderTextGroup.height) / 2,
                        				null);
                        
                        			//If the text exceeds vertical space, move it down so the first line is visible
                        			if ((scene.height - holderTextGroup.height) / 2 &lt; 0) {
                        				holderTextGroup.moveTo(null, 0, null);
                        			}
                        		} else {
                        			textNode = new Shape.Text(scene.text);
                        			line = new Shape.Group(&#x27;line0&#x27;);
                        			line.add(textNode);
                        			holderTextGroup.add(line);
                        
                        			holderTextGroup.moveTo(
                        				(scene.width - tpdata.boundingBox.width) / 2, (scene.height - tpdata.boundingBox.height) / 2,
                        				null);
                        		}
                        
                        		//todo: renderlist
                        
                        		return sceneGraph;
                        	}
                        
                        	/**
                        	 * Adaptive text sizing function
                        	 *
                        	 * @private
                        	 * @param width Parent width
                        	 * @param height Parent height
                        	 * @param fontSize Requested text size
                        	 */
                        	function textSize(width, height, fontSize) {
                        		height = parseInt(height, 10);
                        		width = parseInt(width, 10);
                        		var bigSide = Math.max(height, width);
                        		var smallSide = Math.min(height, width);
                        		var scale = App.defaults.scale;
                        		var newHeight = Math.min(smallSide * 0.75, 0.75 * bigSide * scale);
                        		return Math.round(Math.max(fontSize, newHeight));
                        	}
                        
                        	/**
                        	 * Iterates over resizable (fluid or auto) placeholders and renders them
                        	 *
                        	 * @private
                        	 * @param element Optional element selector, specified only if a specific element needs to be re-rendered
                        	 */
                        	function updateResizableElements(element) {
                        		var images;
                        		if (element == null || element.nodeType == null) {
                        			images = App.vars.resizableImages;
                        		} else {
                        			images = [element];
                        		}
                        		for (var i in images) {
                        			if (!images.hasOwnProperty(i)) {
                        				continue;
                        			}
                        			var el = images[i];
                        			if (el.holderData) {
                        				var flags = el.holderData.flags;
                        				var dimensions = dimensionCheck(el, Holder.invisibleErrorFn(updateResizableElements));
                        				if (dimensions) {
                        					if (flags.fluid &amp;&amp; flags.auto) {
                        						var fluidConfig = el.holderData.fluidConfig;
                        						switch (fluidConfig.mode) {
                        							case &#x27;width&#x27;:
                        								dimensions.height = dimensions.width / fluidConfig.ratio;
                        								break;
                        							case &#x27;height&#x27;:
                        								dimensions.width = dimensions.height * fluidConfig.ratio;
                        								break;
                        						}
                        					}
                        
                        					var drawParams = {
                        						dimensions: dimensions,
                        						theme: flags.theme,
                        						flags: flags
                        					};
                        
                        					if (flags.textmode &amp;&amp; flags.textmode == &#x27;exact&#x27;) {
                        						flags.exactDimensions = dimensions;
                        						drawParams.dimensions = flags.dimensions;
                        					}
                        
                        					render(&#x27;image&#x27;, drawParams, el, el.holderData.renderSettings);
                        				}
                        			}
                        		}
                        	}
                        
                        	/**
                        	 * Checks if an element is visible
                        	 *
                        	 * @private
                        	 * @param el DOM element
                        	 * @param callback Callback function executed if the element is invisible
                        	 */
                        	function dimensionCheck(el, callback) {
                        		var dimensions = {
                        			height: el.clientHeight,
                        			width: el.clientWidth
                        		};
                        		if (!dimensions.height &amp;&amp; !dimensions.width) {
                        			setAttr(el, {
                        				&#x27;data-holder-invisible&#x27;: true
                        			});
                        			callback.call(this, el);
                        		} else {
                        			el.removeAttribute(&#x27;data-holder-invisible&#x27;);
                        			return dimensions;
                        		}
                        	}
                        
                        	/**
                        	 * Sets up aspect ratio metadata for fluid placeholders, in order to preserve proportions when resizing
                        	 *
                        	 * @private
                        	 * @param el Image DOM element
                        	 */
                        	function setInitialDimensions(el) {
                        		if (el.holderData) {
                        			var dimensions = dimensionCheck(el, Holder.invisibleErrorFn(setInitialDimensions));
                        			if (dimensions) {
                        				var flags = el.holderData.flags;
                        
                        				var fluidConfig = {
                        					fluidHeight: flags.dimensions.height.slice(-1) == &#x27;%&#x27;,
                        					fluidWidth: flags.dimensions.width.slice(-1) == &#x27;%&#x27;,
                        					mode: null,
                        					initialDimensions: dimensions
                        				};
                        
                        				if (fluidConfig.fluidWidth &amp;&amp; !fluidConfig.fluidHeight) {
                        					fluidConfig.mode = &#x27;width&#x27;;
                        					fluidConfig.ratio = fluidConfig.initialDimensions.width / parseFloat(flags.dimensions.height);
                        				} else if (!fluidConfig.fluidWidth &amp;&amp; fluidConfig.fluidHeight) {
                        					fluidConfig.mode = &#x27;height&#x27;;
                        					fluidConfig.ratio = parseFloat(flags.dimensions.width) / fluidConfig.initialDimensions.height;
                        				}
                        
                        				el.holderData.fluidConfig = fluidConfig;
                        			}
                        		}
                        	}
                        
                        	//todo: see if possible to convert stagingRenderer to use HTML only
                        	var stagingRenderer = (function() {
                        		var svg = null,
                        			stagingText = null,
                        			stagingTextNode = null;
                        		return function(graph) {
                        			var rootNode = graph.root;
                        			if (App.setup.supportsSVG) {
                        				var firstTimeSetup = false;
                        				var tnode = function(text) {
                        					return document.createTextNode(text);
                        				};
                        				if (svg == null) {
                        					firstTimeSetup = true;
                        				}
                        				svg = initSVG(svg, rootNode.properties.width, rootNode.properties.height);
                        				if (firstTimeSetup) {
                        					stagingText = newEl(&#x27;text&#x27;, SVG_NS);
                        					stagingTextNode = tnode(null);
                        					setAttr(stagingText, {
                        						x: 0
                        					});
                        					stagingText.appendChild(stagingTextNode);
                        					svg.appendChild(stagingText);
                        					document.body.appendChild(svg);
                        					svg.style.visibility = &#x27;hidden&#x27;;
                        					svg.style.position = &#x27;absolute&#x27;;
                        					svg.style.top = &#x27;-100%&#x27;;
                        					svg.style.left = &#x27;-100%&#x27;;
                        					//todo: workaround for zero-dimension &lt;svg&gt; tag in Opera 12
                        					//svg.setAttribute(&#x27;width&#x27;, 0);
                        					//svg.setAttribute(&#x27;height&#x27;, 0);
                        				}
                        
                        				var holderTextGroup = rootNode.children.holderTextGroup;
                        				var htgProps = holderTextGroup.properties;
                        				setAttr(stagingText, {
                        					&#x27;y&#x27;: htgProps.font.size,
                        					&#x27;style&#x27;: cssProps({
                        						&#x27;font-weight&#x27;: htgProps.font.weight,
                        						&#x27;font-size&#x27;: htgProps.font.size + htgProps.font.units,
                        						&#x27;font-family&#x27;: htgProps.font.family,
                        						&#x27;dominant-baseline&#x27;: &#x27;middle&#x27;
                        					})
                        				});
                        
                        				//Get bounding box for the whole string (total width and height)
                        				stagingTextNode.nodeValue = htgProps.text;
                        				var stagingTextBBox = stagingText.getBBox();
                        
                        				//Get line count and split the string into words
                        				var lineCount = Math.ceil(stagingTextBBox.width / (rootNode.properties.width * App.setup.lineWrapRatio));
                        				var words = htgProps.text.split(&#x27; &#x27;);
                        				var newlines = htgProps.text.match(/\\n/g);
                        				lineCount += newlines == null ? 0 : newlines.length;
                        
                        				//Get bounding box for the string with spaces removed
                        				stagingTextNode.nodeValue = htgProps.text.replace(/[ ]+/g, &#x27;&#x27;);
                        				var computedNoSpaceLength = stagingText.getComputedTextLength();
                        
                        				//Compute average space width
                        				var diffLength = stagingTextBBox.width - computedNoSpaceLength;
                        				var spaceWidth = Math.round(diffLength / Math.max(1, words.length - 1));
                        
                        				//Get widths for every word with space only if there is more than one line
                        				var wordWidths = [];
                        				if (lineCount &gt; 1) {
                        					stagingTextNode.nodeValue = &#x27;&#x27;;
                        					for (var i = 0; i &lt; words.length; i++) {
                        						if (words[i].length === 0) continue;
                        						stagingTextNode.nodeValue = decodeHtmlEntity(words[i]);
                        						var bbox = stagingText.getBBox();
                        						wordWidths.push({
                        							text: words[i],
                        							width: bbox.width
                        						});
                        					}
                        				}
                        
                        				return {
                        					spaceWidth: spaceWidth,
                        					lineCount: lineCount,
                        					boundingBox: stagingTextBBox,
                        					words: wordWidths
                        				};
                        			} else {
                        				//todo: canvas fallback for measuring text on android 2.3
                        				return false;
                        			}
                        		};
                        	})();
                        
                        	var sgCanvasRenderer = (function() {
                        		var canvas = newEl(&#x27;canvas&#x27;);
                        		var ctx = null;
                        
                        		return function(sceneGraph) {
                        			if (ctx == null) {
                        				ctx = canvas.getContext(&#x27;2d&#x27;);
                        			}
                        			var root = sceneGraph.root;
                        			canvas.width = App.dpr(root.properties.width);
                        			canvas.height = App.dpr(root.properties.height);
                        			ctx.textBaseline = &#x27;middle&#x27;;
                        
                        			ctx.fillStyle = root.children.holderBg.properties.fill;
                        			ctx.fillRect(0, 0, App.dpr(root.children.holderBg.width), App.dpr(root.children.holderBg.height));
                        
                        			var textGroup = root.children.holderTextGroup;
                        			var tgProps = textGroup.properties;
                        			ctx.font = textGroup.properties.font.weight + &#x27; &#x27; + App.dpr(textGroup.properties.font.size) + textGroup.properties.font.units + &#x27; &#x27; + textGroup.properties.font.family + &#x27;, monospace&#x27;;
                        			ctx.fillStyle = textGroup.properties.fill;
                        
                        			for (var lineKey in textGroup.children) {
                        				var line = textGroup.children[lineKey];
                        				for (var wordKey in line.children) {
                        					var word = line.children[wordKey];
                        					var x = App.dpr(textGroup.x + line.x + word.x);
                        					var y = App.dpr(textGroup.y + line.y + word.y + (textGroup.properties.leading / 2));
                        
                        					ctx.fillText(word.properties.text, x, y);
                        				}
                        			}
                        
                        			return canvas.toDataURL(&#x27;image/png&#x27;);
                        		};
                        	})();
                        
                        	var sgSVGRenderer = (function() {
                        		//Prevent IE &lt;9 from initializing SVG renderer
                        		if (!global.XMLSerializer) return;
                        		var svg = initSVG(null, 0, 0);
                        		var bgEl = newEl(&#x27;rect&#x27;, SVG_NS);
                        		svg.appendChild(bgEl);
                        
                        		//todo: create a reusable pool for textNodes, resize if more words present
                        
                        		return function(sceneGraph, renderSettings) {
                        			var root = sceneGraph.root;
                        
                        			initSVG(svg, root.properties.width, root.properties.height);
                        			var groups = svg.querySelectorAll(&#x27;g&#x27;);
                        
                        			for (var i = 0; i &lt; groups.length; i++) {
                        				groups[i].parentNode.removeChild(groups[i]);
                        			}
                        
                        			setAttr(bgEl, {
                        				&#x27;width&#x27;: root.children.holderBg.width,
                        				&#x27;height&#x27;: root.children.holderBg.height,
                        				&#x27;fill&#x27;: root.children.holderBg.properties.fill
                        			});
                        
                        			var textGroup = root.children.holderTextGroup;
                        			var tgProps = textGroup.properties;
                        			var textGroupEl = newEl(&#x27;g&#x27;, SVG_NS);
                        			svg.appendChild(textGroupEl);
                        
                        			for (var lineKey in textGroup.children) {
                        				var line = textGroup.children[lineKey];
                        				for (var wordKey in line.children) {
                        					var word = line.children[wordKey];
                        					var x = textGroup.x + line.x + word.x;
                        					var y = textGroup.y + line.y + word.y + (textGroup.properties.leading / 2);
                        
                        					var textEl = newEl(&#x27;text&#x27;, SVG_NS);
                        					var textNode = document.createTextNode(null);
                        
                        					setAttr(textEl, {
                        						&#x27;x&#x27;: x,
                        						&#x27;y&#x27;: y,
                        						&#x27;style&#x27;: cssProps({
                        							&#x27;fill&#x27;: tgProps.fill,
                        							&#x27;font-weight&#x27;: tgProps.font.weight,
                        							&#x27;font-family&#x27;: tgProps.font.family + &#x27;, monospace&#x27;,
                        							&#x27;font-size&#x27;: tgProps.font.size + tgProps.font.units,
                        							&#x27;dominant-baseline&#x27;: &#x27;central&#x27;
                        						})
                        					});
                        
                        					textNode.nodeValue = word.properties.text;
                        					textEl.appendChild(textNode);
                        					textGroupEl.appendChild(textEl);
                        				}
                        			}
                        
                        			var svgString = &#x27;data:image/svg+xml;base64,&#x27; +
                        				btoa(unescape(encodeURIComponent(serializeSVG(svg, renderSettings))));
                        			return svgString;
                        		};
                        	})();
                        
                        	//Helpers
                        
                        	/**
                        	 * Generic new DOM element function
                        	 *
                        	 * @private
                        	 * @param tag Tag to create
                        	 * @param namespace Optional namespace value
                        	 */
                        	function newEl(tag, namespace) {
                        		if (namespace == null) {
                        			return document.createElement(tag);
                        		} else {
                        			return document.createElementNS(namespace, tag);
                        		}
                        	}
                        
                        	/**
                        	 * Generic setAttribute function
                        	 *
                        	 * @private
                        	 * @param el Reference to DOM element
                        	 * @param attrs Object with attribute keys and values
                        	 */
                        	function setAttr(el, attrs) {
                        		for (var a in attrs) {
                        			el.setAttribute(a, attrs[a]);
                        		}
                        	}
                        
                        	/**
                        	 * Generic SVG element creation function
                        	 *
                        	 * @private
                        	 * @param svg SVG context, set to null if new
                        	 * @param width Document width
                        	 * @param height Document height
                        	 */
                        	function initSVG(svg, width, height) {
                        		if (svg == null) {
                        			svg = newEl(&#x27;svg&#x27;, SVG_NS);
                        			var defs = newEl(&#x27;defs&#x27;, SVG_NS);
                        			svg.appendChild(defs);
                        		}
                        		//IE throws an exception if this is set and Chrome requires it to be set
                        		if (svg.webkitMatchesSelector) {
                        			svg.setAttribute(&#x27;xmlns&#x27;, SVG_NS);
                        		}
                        
                        		setAttr(svg, {
                        			&#x27;width&#x27;: width,
                        			&#x27;height&#x27;: height,
                        			&#x27;viewBox&#x27;: &#x27;0 0 &#x27; + width + &#x27; &#x27; + height,
                        			&#x27;preserveAspectRatio&#x27;: &#x27;none&#x27;
                        		});
                        		return svg;
                        	}
                        
                        	/**
                        	 * Generic SVG serialization function
                        	 *
                        	 * @private
                        	 * @param svg SVG context
                        	 * @param stylesheets CSS stylesheets to include
                        	 */
                        	function serializeSVG(svg, renderSettings) {
                        		if (!global.XMLSerializer) return;
                        		var serializer = new XMLSerializer();
                        		var svgCSS = &#x27;&#x27;;
                        		var stylesheets = renderSettings.stylesheets;
                        		var defs = svg.querySelector(&#x27;defs&#x27;);
                        
                        		//External stylesheets: Processing Instruction method
                        		if (renderSettings.svgXMLStylesheet) {
                        			var xml = new DOMParser().parseFromString(&#x27;&lt;xml /&gt;&#x27;, &#x27;application/xml&#x27;);
                        			//Add &lt;?xml-stylesheet ?&gt; directives
                        			for (var i = stylesheets.length - 1; i &gt;= 0; i--) {
                        				var csspi = xml.createProcessingInstruction(&#x27;xml-stylesheet&#x27;, &#x27;href=&quot;&#x27; + stylesheets[i] + &#x27;&quot; rel=&quot;stylesheet&quot;&#x27;);
                        				xml.insertBefore(csspi, xml.firstChild);
                        			}
                        
                        			//Add &lt;?xml ... ?&gt; UTF-8 directive
                        			var xmlpi = xml.createProcessingInstruction(&#x27;xml&#x27;, &#x27;version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;&#x27;);
                        			xml.insertBefore(xmlpi, xml.firstChild);
                        			xml.removeChild(xml.documentElement);
                        			svgCSS = serializer.serializeToString(xml);
                        		}
                        
                        		/*
                        
                        		//External stylesheets: &lt;link&gt; method
                        		if (renderSettings.svgLinkStylesheet) {
                        
                        			defs.removeChild(defs.firstChild);
                        			for (i = 0; i &lt; stylesheets.length; i++) {
                        				var link = document.createElementNS(&#x27;http://www.w3.org/1999/xhtml&#x27;, &#x27;link&#x27;);
                        				link.setAttribute(&#x27;href&#x27;, stylesheets[i]);
                        				link.setAttribute(&#x27;rel&#x27;, &#x27;stylesheet&#x27;);
                        				link.setAttribute(&#x27;type&#x27;, &#x27;text/css&#x27;);
                        				defs.appendChild(link);
                        			}
                        		}
                        
                        		//External stylesheets: &lt;style&gt; and @import method
                        		if (renderSettings.svgImportStylesheet) {
                        			var style = document.createElementNS(SVG_NS, &#x27;style&#x27;);
                        			var styleText = [];
                        
                        			for (i = 0; i &lt; stylesheets.length; i++) {
                        				styleText.push(&#x27;@import url(&#x27; + stylesheets[i] + &#x27;);&#x27;);
                        			}
                        
                        			var styleTextNode = document.createTextNode(styleText.join(&#x27;\n&#x27;));
                        			style.appendChild(styleTextNode);
                        			defs.appendChild(style);
                        		}
                        
                        		*/
                        
                        		var svgText = serializer.serializeToString(svg);
                        		svgText = svgText.replace(/\&amp;amp;(\#[0-9]{2,}\;)/g, &#x27;&amp;$1&#x27;);
                        		return svgCSS + svgText;
                        	}
                        
                        	/**
                        	 * Shallow object clone and merge
                        	 *
                        	 * @param a Object A
                        	 * @param b Object B
                        	 * @returns {Object} New object with all of A&#x27;s properties, and all of B&#x27;s properties, overwriting A&#x27;s properties
                        	 */
                        	function extend(a, b) {
                        		var c = {};
                        		for (var x in a) {
                        			if (a.hasOwnProperty(x)) {
                        				c[x] = a[x];
                        			}
                        		}
                        		if (b != null) {
                        			for (var y in b) {
                        				if (b.hasOwnProperty(y)) {
                        					c[y] = b[y];
                        				}
                        			}
                        		}
                        		return c;
                        	}
                        
                        	/**
                        	 * Takes a k/v list of CSS properties and returns a rule
                        	 *
                        	 * @param props CSS properties object
                        	 */
                        	function cssProps(props) {
                        		var ret = [];
                        		for (var p in props) {
                        			if (props.hasOwnProperty(p)) {
                        				ret.push(p + &#x27;:&#x27; + props[p]);
                        			}
                        		}
                        		return ret.join(&#x27;;&#x27;);
                        	}
                        
                        	/**
                        	 * Prevents a function from being called too often, waits until a timer elapses to call it again
                        	 *
                        	 * @param fn Function to call
                        	 */
                        	function debounce(fn) {
                        		if (!App.vars.debounceTimer) fn.call(this);
                        		if (App.vars.debounceTimer) clearTimeout(App.vars.debounceTimer);
                        		App.vars.debounceTimer = setTimeout(function() {
                        			App.vars.debounceTimer = null;
                        			fn.call(this);
                        		}, App.setup.debounce);
                        	}
                        
                        	/**
                        	 * Holder-specific resize/orientation change callback, debounced to prevent excessive execution
                        	 */
                        	function resizeEvent() {
                        		debounce(function() {
                        			updateResizableElements(null);
                        		});
                        	}
                        
                        	/**
                        	 * Converts a value into an array of DOM nodes
                        	 *
                        	 * @param val A string, a NodeList, a Node, or an HTMLCollection
                        	 */
                        	function getNodeArray(val) {
                        		var retval = null;
                        		if (typeof(val) == &#x27;string&#x27;) {
                        			retval = document.querySelectorAll(val);
                        		} else if (global.NodeList &amp;&amp; val instanceof global.NodeList) {
                        			retval = val;
                        		} else if (global.Node &amp;&amp; val instanceof global.Node) {
                        			retval = [val];
                        		} else if (global.HTMLCollection &amp;&amp; val instanceof global.HTMLCollection) {
                        			retval = val;
                        		} else if (val === null) {
                        			retval = [];
                        		}
                        		return retval;
                        	}
                        
                        	/**
                        	 * Checks if an image exists
                        	 *
                        	 * @param params Configuration object, must specify at least a src key
                        	 * @param callback Callback to call once image status has been found
                        	 */
                        	function imageExists(src, callback) {
                        		var image = new Image();
                        		image.onerror = function() {
                        			callback.call(this, false);
                        		};
                        		image.onload = function() {
                        			callback.call(this, true);
                        		};
                        		image.src = src;
                        	}
                        
                        	/**
                        	 * Encodes HTML entities in a string
                        	 *
                        	 * @param str Input string
                        	 */
                        	function encodeHtmlEntity(str) {
                        		var buf = [];
                        		var charCode = 0;
                        		for (var i = str.length - 1; i &gt;= 0; i--) {
                        			charCode = str.charCodeAt(i);
                        			if (charCode &gt; 128) {
                        				buf.unshift([&#x27;&amp;#&#x27;, charCode, &#x27;;&#x27;].join(&#x27;&#x27;));
                        			} else {
                        				buf.unshift(str[i]);
                        			}
                        		}
                        		return buf.join(&#x27;&#x27;);
                        	}
                        
                        	/**
                        	 * Decodes HTML entities in a stirng
                        	 *
                        	 * @param str Input string
                        	 */
                        	function decodeHtmlEntity(str) {
                        		return str.replace(/&amp;#(\d+);/g, function(match, dec) {
                        			return String.fromCharCode(dec);
                        		});
                        	}
                        
                        	// Scene graph
                        
                        	var SceneGraph = function(sceneProperties) {
                        		var nodeCount = 1;
                        
                        		//todo: move merge to helpers section
                        		function merge(parent, child) {
                        			for (var prop in child) {
                        				parent[prop] = child[prop];
                        			}
                        			return parent;
                        		}
                        
                        		var SceneNode = augment.defclass({
                        			constructor: function(name) {
                        				nodeCount++;
                        				this.parent = null;
                        				this.children = {};
                        				this.id = nodeCount;
                        				this.name = &#x27;n&#x27; + nodeCount;
                        				if (name != null) {
                        					this.name = name;
                        				}
                        				this.x = 0;
                        				this.y = 0;
                        				this.z = 0;
                        				this.width = 0;
                        				this.height = 0;
                        			},
                        			resize: function(width, height) {
                        				if (width != null) {
                        					this.width = width;
                        				}
                        				if (height != null) {
                        					this.height = height;
                        				}
                        			},
                        			moveTo: function(x, y, z) {
                        				this.x = x != null ? x : this.x;
                        				this.y = y != null ? y : this.y;
                        				this.z = z != null ? z : this.z;
                        			},
                        			add: function(child) {
                        					var name = child.name;
                        					if (this.children[name] == null) {
                        						this.children[name] = child;
                        						child.parent = this;
                        					} else {
                        						throw &#x27;SceneGraph: child with that name already exists: &#x27; + name;
                        					}
                        				}
                        				/*,	// probably unnecessary in Holder
                        				remove: function(name){
                        					if(this.children[name] == null){
                        						throw &#x27;SceneGraph: child with that name doesn\&#x27;t exist: &#x27;+name;
                        					}
                        					else{
                        						child.parent = null;
                        						delete this.children[name];
                        					}
                        				},
                        				removeAll: function(){
                        					for(var child in this.children){
                        						this.remove(child);
                        					}
                        				}*/
                        		});
                        
                        		var RootNode = augment(SceneNode, function(uber) {
                        			this.constructor = function() {
                        				uber.constructor.call(this, &#x27;root&#x27;);
                        				this.properties = sceneProperties;
                        			};
                        		});
                        
                        		var Shape = augment(SceneNode, function(uber) {
                        			function constructor(name, props) {
                        				uber.constructor.call(this, name);
                        				this.properties = {
                        					fill: &#x27;#000&#x27;
                        				};
                        				if (props != null) {
                        					merge(this.properties, props);
                        				} else if (name != null &amp;&amp; typeof name !== &#x27;string&#x27;) {
                        					throw &#x27;SceneGraph: invalid node name&#x27;;
                        				}
                        			}
                        
                        			this.Group = augment.extend(this, {
                        				constructor: constructor,
                        				type: &#x27;group&#x27;
                        			});
                        
                        			this.Rect = augment.extend(this, {
                        				constructor: constructor,
                        				type: &#x27;rect&#x27;
                        			});
                        
                        			this.Text = augment.extend(this, {
                        				constructor: function(text) {
                        					constructor.call(this);
                        					this.properties.text = text;
                        				},
                        				type: &#x27;text&#x27;
                        			});
                        		});
                        
                        		var root = new RootNode();
                        
                        		this.Shape = Shape;
                        		this.root = root;
                        
                        		return this;
                        	};
                        
                        	//Set up flags
                        
                        	for (var flag in App.flags) {
                        		if (!App.flags.hasOwnProperty(flag)) continue;
                        		App.flags[flag].match = function(val) {
                        			return val.match(this.regex);
                        		};
                        	}
                        
                        	//Properties set once on setup
                        
                        	App.setup = {
                        		renderer: &#x27;html&#x27;,
                        		debounce: 100,
                        		ratio: 1,
                        		supportsCanvas: false,
                        		supportsSVG: false,
                        		lineWrapRatio: 0.9,
                        		renderers: [&#x27;html&#x27;, &#x27;canvas&#x27;, &#x27;svg&#x27;]
                        	};
                        
                        	App.dpr = function(val) {
                        		return val * App.setup.ratio;
                        	};
                        
                        	//Properties modified during runtime
                        
                        	App.vars = {
                        		preempted: false,
                        		resizableImages: [],
                        		debounceTimer: null,
                        		cache: {}
                        	};
                        
                        	//Pre-flight
                        
                        	(function() {
                        		var devicePixelRatio = 1,
                        			backingStoreRatio = 1;
                        
                        		var canvas = newEl(&#x27;canvas&#x27;);
                        		var ctx = null;
                        
                        		if (canvas.getContext) {
                        			if (canvas.toDataURL(&#x27;image/png&#x27;).indexOf(&#x27;data:image/png&#x27;) != -1) {
                        				App.setup.renderer = &#x27;canvas&#x27;;
                        				ctx = canvas.getContext(&#x27;2d&#x27;);
                        				App.setup.supportsCanvas = true;
                        			}
                        		}
                        
                        		if (App.setup.supportsCanvas) {
                        			devicePixelRatio = global.devicePixelRatio || 1;
                        			backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
                        		}
                        
                        		App.setup.ratio = devicePixelRatio / backingStoreRatio;
                        
                        		if (!!document.createElementNS &amp;&amp; !!document.createElementNS(SVG_NS, &#x27;svg&#x27;).createSVGRect) {
                        			App.setup.renderer = &#x27;svg&#x27;;
                        			App.setup.supportsSVG = true;
                        		}
                        	})();
                        
                        	//Exposing to environment and setting up listeners
                        	register(Holder, &#x27;Holder&#x27;, global);
                        
                        	if (global.onDomReady) {
                        		global.onDomReady(function() {
                        			if (!App.vars.preempted) {
                        				Holder.run();
                        			}
                        			if (global.addEventListener) {
                        				global.addEventListener(&#x27;resize&#x27;, resizeEvent, false);
                        				global.addEventListener(&#x27;orientationchange&#x27;, resizeEvent, false);
                        			} else {
                        				global.attachEvent(&#x27;onresize&#x27;, resizeEvent);
                        			}
                        
                        			if (typeof global.Turbolinks == &#x27;object&#x27;) {
                        				global.document.addEventListener(&#x27;page:change&#x27;, function() {
                        					Holder.run();
                        				});
                        			}
                        		});
                        	}
                        
                        })(function(fn, name, global) {
                        	var isAMD = (typeof define === &#x27;function&#x27; &amp;&amp; define.amd);
                        	var isNode = (typeof exports === &#x27;object&#x27;);
                        	var isWeb = !isNode;
                        
                        	if (isAMD) {
                        		define(fn);
                        	} else {
                        		//todo: npm/browserify registration
                        		global[name] = fn;
                        	}
                        }, this);
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
